---
title: Java之文本文件的创建和读取（含IO流操作）
date: 2018-02-06 22:47:00
---
###### 工具类：对文件的读取，创建。直接复制拿来用！


```java
package cn.zyzpp.util;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;

public class TxtUtil {
    /**
     *  读取文件
     * @param path
     * @return 文件的字符串内容
     */
    public static String test(String path) {
        try {
            String pathname = path;
            // File对象
            File filename = new File(pathname);
            // 文件字节输入流对象
            FileInputStream fileInputStream = new FileInputStream(filename);
            // 字节转字符输入流对象 InputStreamReader：字节流到字符流的桥梁
            InputStreamReader reader = new InputStreamReader(fileInputStream, "utf-8");
            // BufferedReader(字符缓冲输入流)，提供通用的缓冲方式文本读取
            BufferedReader br = new BufferedReader(reader);
            // 多线程StringBuffer 单线程StringBuilder
            StringBuffer txt = new StringBuffer();
            String line = "";
            while ((line = br.readLine()) != null) {
                txt.append(line);
            }
            // 方法一：流的关闭：先打开的后关闭，后打开的先关闭
            // 方法二：可以只调用外层流的close方法关闭其装饰的内层流
            br.close();
            return txt.toString();
        } catch (Exception e) {
            // e.printStackTrace();
            return null;
        }
    }
    
    /**
     * 写入Txt
     * @param path
     * @param txt
     * @throws IOException
     */
    public static boolean writeFile(String path, String txt) {
        // 相对路径，如果没有则要建立一个新的path文件
        File file = new File(path);
        try {
            // 创建新文件
            file.createNewFile();
            // 字符缓冲输出流：写东西到该文件
            BufferedWriter out = new BufferedWriter(new FileWriter(file));
            // 写东西：\r\n即为换行
            out.write(txt);
            // 把缓存区内容压入文件
            out.flush();
            // 最后关闭流
            out.close();
            //返回成功
            return true;
        } catch (IOException e) {
            //e.printStackTrace();
            //返回失败
            return false;
        }
    }

}
```