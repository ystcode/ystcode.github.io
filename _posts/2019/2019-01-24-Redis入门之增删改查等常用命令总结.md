---
layout: post
title: Redis入门之增删改查等常用命令总结
date: 2019-01-24 19:54:00
author: 薛师兄
tags: Redis
---
Redis是用C语言实现的，一般来说C语言实现的程序“距离”操作系统更近，执行速度相对会更快。

Redis使用了单线程架构，预防了多线程可能产生的竞争问题。

作者对于Redis源代码可以说是精打细磨，曾经有人评价Redis是少有的集性能和优雅于一身的开源代码。

本文比较详细且全面的梳理了Redis使用过程中涉及的全部增删改查！

## Linux 下安装

**下载地址：**<http://redis.io/download>，下载最新稳定版本。

本教程使用的最新文档版本为 2.8.17，下载并安装：

```java
$ wget http://download.redis.io/releases/redis-2.8.17.tar.gz
$ tar xzf redis-2.8.17.tar.gz
$ cd redis-2.8.17
$ make test
```

make完后 redis-2.8.17目录下会出现编译后的redis服务程序redis-server,还有用于测试的客户端程序redis-cli,两个程序位于安装目录 src 目录下：

下面启动redis服务.

```java
$ cd src
$ ./redis-server
```

注意这种方式启动redis 使用的是默认配置。也可以通过启动参数告诉redis使用指定配置文件使用下面命令启动。

```java
$ cd src
$ ./redis-server ../redis.conf
```

**redis.conf** 是一个默认的配置文件。我们可以根据需要使用自己的配置文件。

启动redis服务进程后，就可以使用测试客户端程序redis-cli和redis服务交互了。 比如：

```java
$ cd src
$ ./redis-cli
redis> set foo bar
OK
redis> get foo
"bar"
```

## 1.字符串
1.设置键
```java
set key value [ex seconds] [px milliseconds] [nx|xx]

setex key seconds value
setnx key value
```
- ex seconds：为键设置秒级过期时间。
- px milliseconds：为键设置毫秒级过期时间。
- nx：键必须不存在，才可以设置成功，用于添加。
- xx：与nx相反，键必须存在，才可以设置成功，用于更新。

2.批量设置值

```java
mset key value [key value ...]
```
3.批量获取值
```java
mget key [key ...]
```
4.计数
```java
incr key
```
- 值不是整数，返回错误。
- 值是整数，返回自增后的结果。
- 键不存在，按照值为0自增，返回结果为1

decr（自减）、incrby（自增指定数字）、
decrby（自减指定数字）、incrbyfloat（自增浮点数）

4.追加值
```java
append key value
```
5.字符串长度
```java
strlen key
```
6.设置并返回原值
```java
getset key value
```
7.设置指定位置的字符
```java
setrange key offeset value
```
8.获取部分字符串
```java
getrange key start end
```

## 2.哈希
1.设置值
```java
hset key field value
```
2.获取值
```java
hget key field
```
3.删除filed
```java
hdel key field [field ...]
```
4.计算field个数
```java
hlen key
```
5.批量设置或获取field-value
```java
hmget key field [field ...]
hmset key field value [field value ...]
```
6.判断field是否存在
```java
hexists key field
```
7.获取所有field
```java
hkeys key
```
8.获取所有value
```java
hvals key
```
9.获取所有的field-value
```java
hgetall key
```
10.hincrby hincrbyfloat
```java
hincrby key field
hincrbyfloat key field
```
11.计算value的字符串长度
```java
hstrlen key field
```
## 3.列表
1）添加

left/right

1.从右边插入元素
```java
rpush key value [value ...]
```
lrange listkey 0 -1 可以从左到右获取列表的所有元素

2.从左边插入元素
```java
lpush key value [value ...]
```
3.向某个元素前或者后插入元素
```java
linsert key before|after pivot value
```

2）查找

1.获取指定范围内的元素列表
```java
lrange key start end
```
2.获取列表指定索引下标的元素
```java
lindex key index
```
3.获取列表长度
```java
llen key
```
3）删除

1.从列表左侧弹出元素
```java
lpop key
```
2.从列表右侧弹出
```java
rpop key
```
3.删除指定元素
```java
lrem key count value
```
- count>0，从左到右，删除最多count个元素。
- count<0，从右到左，删除最多count绝对值个元素。
- count=0，删除所有。

4.按照索引范围修剪列表
```java
ltrim key start end
```
4）修改

修改指定索引下标的元素
```java
lset key index newValue
```
5）阻塞操作

```java
blpop key [key ...] timeout
brpop key [key ...] timeout
```
- key[key...]：多个列表的键
- timeout：阻塞时间（单位：秒）

**开发技巧**

- lpush+lpop=Stack（栈）
- lpush+rpop=Queue（队列）
- lpsh+ltrim=Capped Collection（有限集合）
- lpush+brpop=Message Queue（消息队列）

## 4.集合
集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一样的是，集合中**不允许有重复**元素，并且集合中的元素是**无序**的，不能通过索引下标获取元素。

1.添加元素
```java
sadd key element [element ...]
```
2.删除元素
```java
srem key element [element ...]
```
3.计算元素个数
```java
scard key
```
4.判断元素是否在集合中
```java
sismember key element
```
5.随机从集合返回指定个数元素
```java
srandmember key [count]
```
6.从集合随机弹出元素
```java
spop key
```
7.获取所有元素
```java
smembers key
```
8.求多个集合的交集

```java
sinter key [key ...]
```
9.求多个集合的并集

```java
suinon key [key ...]
```
10.求多个集合的差集

```java
sdiff key [key ...]
```
11.将交集、并集、差集的结果保存

```java
sinterstore destination key [key ...]
suionstore destination key [key ...]
sdiffstore destination key [key ...]
```
三个命令（原命令+store）将集合间交集、并集、差集的结果保存在destination中

## 5.有序集合

1.添加成员
```java
zadd key score member [score member ...]

#zadd key1 1 value1
```
Redis3.2为zadd命令添加了nx、xx、ch、incr四个选项：

- nx：member必须不存在，才可以设置成功，用于添加。
- xx：member必须存在，才可以设置成功，用于更新。
- ch：返回此次操作后，有序集合元素和分数发生变化的个数。
- incr：对score做增加，相当于后面介绍的zincrby。

2.计算成员个数
```java
zcard key
```
3.计算某个成员的分数
```java
zscore key member
```
4.计算成员的排名
```java
zrank key member
zrevrank key member
```
5.删除成员
```java
zrem key member [member ...]
```
6.增加成员的分数

```java
zincrby key increment member
zincrby user:ranking 9 tom
```
7.返回指定排名范围的成员

```java
zrange key start end [withscores]
zrevrange key start end [withscores]
```
zrange是从低到高返回，zrevrange反之。

8.返回指定分数范围的成员
```java
zrangebyscore key min max [withscores] [limit offset count]
zrevrangebyscore key max min [withscores] [limit offset count]
```
其中zrangebyscore按照分数从低到高返回，zrevrangebyscore反之。

同时min和max还支持开区间（小括号）和闭区间（中括号），-inf和+inf分别代表无限小和无限大。

9.返回指定分数范围成员个数
```java
zcount key min max
```
10.删除指定排名内的升序元素

```java
zremrangebyrank key start end
```
11.删除指定分数范围的成员

```java
zremrangebyscore key min max
```
12.交集
```java
zinterstore destination numkeys key [key ...] [weights weight [weight ...]]
[aggregate sum|min|max]
```
- destination：交集计算结果保存到这个键。
- numkeys：需要做交集计算键的个数。
- key[key...]：需要做交集计算的键。
- weights weight[weight...]：每个键的权重，在做交集计算时，每个键中的每个member会将自己分数乘以这个权重，每个键的权重默认是1。
- aggregate sum|min|max：计算成员交集后，分值可以按照sum（和）、min（最小值）、max（最大值）做汇总，默认值是sum。

```java
zinterstore user:ranking:1_inter_2 2 user:ranking:1
user:ranking:2 weights 1 0.5 aggregate max
```
13.并集

```java
zunionstore destination numkeys key [key ...] [weights weight [weight ...]][aggregate sum|min|max]
```

## 6.键管理

键重命名

```java
rename key newkey
```
随机返回一个键

```java
randomkey
```

## 7.键过期

- expire key seconds：键在seconds秒后过期。
- expireat key timestamp：键在秒级时间戳timestamp后过期。


```java
set hello world

expire hello 10

ttl hello
```
通过ttl观察它的过期剩余时间（s），返回结果为-2时，代表已被删除。

ttl 和 ptll都可以查询键的剩余时间，但是pttl的精度可以达到毫秒级别，有3种返回值：
- 大于等于0的整数：键剩余的过期时间（ttl是秒，pttl是毫秒）
- -1：键没有设置过期时间
- -2：键不存在

expireat命令可以设置键的秒级过期时间戳，例如如果需要将键hello在2016-08-0100：00：00（秒级时间戳为1469980800）过期，可以执行如下操作：

```java
expireat hello 1469980800
```
除此之外，Redis2.6版本后提供了毫秒级的过期方案：
- pexpire key milliseconds：键在milliseconds毫秒后过期。
- pexpireat key milliseconds-timestamp键在毫秒级时间戳timestamp后过
  期。

但无论是使用过期时间还是时间戳，秒级还是毫秒级，在Redis内部最终使用的都是pexpireat。

1. 如果expire key的键不存在，返回结果为0
2. 如果过期时间为负值，键会立即被删除，犹如使用del命令一样
3. persist命令可以将键的过期时间清除：`persist hello`
4. 对于字符串类型键，执行set命令会去掉过期时间
5. Redis不支持二级数据结构（例如哈希、列表）内部元素的过期功能，例如不能对列表类型的一个元素做过期时间设置
6. setex命令作为set+expire的组合，不但是原子执行，同时减少了一次网络通讯的时间。

## 8.迁移键

1）move key db

仅限于内部数据库的迁移

2）dump+restore


```java
dump key
restore key ttl value
```


分为两步：

1.在源Redis上，dump命令会将键值序列化，格式采用的是RDB格式。

2.在目标Redis上，restore命令将上面序列化的值进行复原，其中ttl参数代表过期时间，如果ttl=0代表没有过期时间。

示例：

1在源Redis上执行dump：

```java
127.0.0.1:6379> set hello world
OK
127.0.0.1:6379> dump hello
"\x00\x05world\b\x00\xa0\xfc\xd0;y\xb0\xf8\xfa"
```
2在目标Redis上执行restore

```java
127.0.0.1:6379> get hello
(nil)
127.0.0.1:6379> restore hello 0 "\x00\x05world\b\x00\xa0\xfc\xd0;y\xb0\xf8\xfa"
OK
127.0.0.1:6379> get hello
"world"
```
上面两步对应的伪代码为

```java
Redis sourceRedis = new Redis("sourceMachine", 6379);
Redis targetRedis = new Redis("targetMachine", 6379);
targetRedis.restore("hello", 0, sourceRedis.dump(key));
```
3）migrate（推荐）

```java
migrate host port key|"" destination-db timeout [copy] [replace] [keys key [key]]
```
下面对migrate的参数进行逐个说明：
- host：目标Redis的IP地址。
- port：目标Redis的端口。
- key|""：在Redis3.0.6版本之前，migrate只支持迁移一个键，所以此处是
  要迁移的键，但Redis3.0.6版本之后支持迁移多个键，如果当前需要迁移多个键，此处为空字符串""。
- destination-db：目标Redis的数据库索引，例如要迁移到0号数据库，这里就写0。
- timeout：迁移的超时时间（单位为毫秒）。
- [copy]：如果添加此选项，迁移后并不删除源键。
- [replace]：如果添加此选项，migrate不管目标Redis是否存在该键都会
  正常迁移进行数据覆盖。
- [keys key[key...]]：迁移多个键，例如要迁移key1、key2、key3，此处填
  写“keys key1 key2 key3”。

第一，整个过程是原子执行的，不需要在多个Redis实例上开启客户端的，只需要在源Redis上执行migrate命令即可。

第二，migrate命令的数据传输直接在源Redis和目标Redis上完成的。

第三，目标Redis完成restore后会发送OK给源Redis，源Redis接收后会根据migrate对应的选项来决定是否在源Redis上删除对应的键。

示例：

1源Redis有,目标没有

```java
migrate 127.0.0.1 6380 hello 0 1000
```
2源Redis和目标Redis都有键hello

```java
migrate 127.0.0.1 6379 hello 0 1000 replace
```

源Redis批量添加多个键

```java
mset key1 value1 key2 value2 key3 value3
```
源Redis执行如下命令完成多个键的迁移

```java
migrate 127.0.0.1 6380 "" 0 5000 keys key1 key2 key3
```
## 9.遍历键
1）全量遍历键
```java
keys pattern
```
示例：
```java
keys *
```
- *代表任意字符
- ?代表一个字符
- []代表匹配部分字符,例如[1,3]代表匹配1,3
- \x用来做转义，例如要匹配星号、问号需要进行转义

如果Redis包含了大量的键，执行keys命令很可能会造成Redis阻塞，所以一般建议不要在生产环境下使用keys命令。

2）渐进式遍历

每次执行scan，可以想象成只扫描一个字典中的一部分键，直到将字典中的所有键遍历完毕。


```java
scan cursor [match pattern] [count number]
```
- cursor是必需参数，实际上cursor是一个游标，第一次遍历从0开始，每次scan遍历完都会返回当前游标的值，直到游标值为0，表示遍历结束。

- match pattern是可选参数，它的作用的是做模式的匹配，这点和keys的模式匹配很像。

- count number是可选参数，它的作用是表明每次要遍历的键个数，默认值是10，此参数可以适当增大。

## 10.数据库管理

1.切换数据库

```java
select dbIndex
```
默认有16个

2.flushdb/flushall

flushdb只清除当前数据库，flushall会清除所有数据库。

## 11.慢查询分析

所谓慢查询日志就是系统在命令执行前后计算每条命令的执行时间，当超过预设阀值，就将这条命令的相关信息（例如：发生时间，耗时，命令的详细信息）记录下来。慢查询功能可以有效地帮助我们找到Redis可能存在的瓶颈.

## 12.Pipeline

Pipeline（流水线）机制它能将一组Redis命令进行组装，通过一次RTT传输给Redis，再将这组Redis命令的执行结果按顺序返回给客户端。

## 13.事务

熟悉关系型数据库的读者应该对事务比较了解，简单地说，事务表示一组动作，要么全部执行，要么全部不执行。

Redis提供了简单的事务功能，将一组需要一起执行的命令放到multi和exec两个命令之间。如果要停止事务的执行，可以使用discard命令代替exec命令即可。

## 14.关机

```java
shutdown
```

Redis关闭的过程：断开与客户端的连接、持久化文件生成，是一种相对优雅的关闭方式。

也可以kill掉，但不要kill -9，shutdown参数有nosave|save

## 15.安全

设置密码(""：无)

```java
config set requirepass "password"
```

登录

```java
auth "password"
```

获取密码

```java
config get requirepass
```

## 16.持久化

所有的数据都存在内存中，从内存当中同步到硬盘上，这个过程叫做持久化过程。
持久化操作，两种方式：rdb方式、aof方式，可以单独使用或者结合使用。

RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储.

AOF持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以redis协议追加保存每次写的操作到文件末尾。Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。

**RDB配置**

在redis.conf中的配置

```java
save 900 1
save 300 10
save 60 10000
dbfilename dump.rdb
dir ./
```

意思是在900秒内有1个key发生变化，就写一次硬盘。

Linux保存在 redis.conf 同级目录

**AOF配置**

```java
# 默认不开启AOF
appendonly no #使用改成yes

# 同步策略
# appendfsync always #修改一次 （推荐）
appendfsync everysec #每秒同步
# appendfsync no #不同步
```

配置完记得重启！

## 17.BitMap

Redis从2.2.0版本开始新增了setbit,getbit,bitcount等几个bitmap相关命令。虽然是新命令，但是并没有新增新的数据类型，因为setbit等命令只不过是在set上的扩展。

setbit命令介绍
指令 `SETBIT key offset value`
复杂度 O(1)
设置或者清空key的value(字符串)在offset处的bit值(只能只0或者1)。
大概的空间占用计算公式是：($offset/8/1024/1024)MB