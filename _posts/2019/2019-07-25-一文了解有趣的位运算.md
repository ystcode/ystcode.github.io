---
layout: post
title: 一文了解有趣的位运算（&、|、^、~、>>、<<）
date: 2019-07-25 15:26:00
author: 薛勤
tags: 算法
---
## 一、位运算概述

从现代计算机中所有的数据二进制的形式存储在设备中。即0、1两种状态，计算机对二进制数据进行的运算(+、-、\*、/)都是叫位运算，即将符号位共同参与运算的运算。

口说无凭，举一个简单的例子来看下CPU是如何进行计算的，比如这行代码：

```java
int a = 35;
int b = 47;
int c = a + b;
```

计算两个数的和，因为在计算机中都是以二进制来进行运算，所以上面我们所给的int变量会在机器内部先转换为二进制在进行相加：

```java
35:  0 0 1 0 0 0 1 1
47:  0 0 1 0 1 1 1 1
————————————————————
82:  0 1 0 1 0 0 1 0
```

由此可见，相比在代码中直接使用(+、-、\*、/)运算符，合理的运用位运算更能显著提高代码在机器上的执行效率。

## 二、位运算概览

本文涉及的位运算符如下表格所示，关于每一个位运算的详细用法与常见面试题会在后面一一写出。

| 符号 | 描述       | 运算规则                                                     |
| ---- | ---------- | ------------------------------------------------------------ |
| &    | 与         | 两个位都为1时，结果才为1                                     |
| \|   | 或         | 两个位都为0时，结果才为0                                     |
| ^    | 异或       | 两个位相同为0，相异为1                                       |
| ~    | 取反       | 0变1，1变0                                                   |
| <<   | 左移       | 各二进位全部左移若干位，高位丢弃，低位补0                    |
| >>   | 右移       | 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移） |
| \>>> | 无符号右移 | 无符号右移，忽略符号位，空位都以0补齐                        |

### 2.1 按位与运算符（&）

**定义**：参加运算的两个数据，按二进制位进行“与”运算。

**运算规则**：

```java
0&0=0  0&1=0  1&0=0  1&1=1
```

**总结**：两位同时为**1**，结果才为**1**，否则结果为**0**。

**例如**：`3&5` 即 0000 0011& 0000 0101 = 0000 0001，因此 3&5 的值得1。

**注意**：负数按**补码**形式参加按位与运算。

#### 常见面试题

##### 1）清零

如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。

##### 2）取一个数的指定位

比如取数 X=1010 1110 的低4位，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位与运算（X&Y=0000 1110）即可得到X的指定位。

##### 3）判断一个数奇偶

只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。

因此可以用`if ((a & 1) == 0)`代替`if (a % 2 == 0)`来判断a是不是偶数。

### 2.2 按位或运算符（|）

**定义**：参加运算的两个对象，按二进制位进行“或”运算。

**运算规则**：

```java
0|0=0  0|1=1  1|0=1  1|1=1
```

**总结**：参加运算的两个对象只要有一个为1，其值为1。

**例如**：`3|5`即 0000 0011| 0000 0101 = 0000 0111，因此，`3|5`的值得7。　

**注意**：负数按**补码**形式参加按位或运算。

#### 常见面试题

##### 1）常用来对一个数据的某些位设置为1

比如将数 X=1010 1110 的低4位设置为1，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位或运算（X|Y=1010 1111）即可得到。

### 2.3 异或运算符（^）

**定义**：参加运算的两个数据，按二进制位进行“异或”运算。

**运算规则**：

```java
0^0=0  0^1=1  1^0=1  1^1=0
```

**总结**：参加运算的两个对象，如果两个相应位相同为0，相异为1。

**异或运算性质**:

1、交换律

2、结合律 (a^b)^c == a^(b^c)

3、对于任何数x，都有 x^x=0，x^0=x

4、自反性: a^b^b=a^0=a;

#### 常见面试题

##### 1）翻转指定位

比如将数 X=1010 1110 的低4位进行翻转，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行异或运算（X^Y=1010 0001）即可得到。

##### 2）与0相异或值不变 

例如：1010 1110 ^ 0000 0000 = 1010 1110

##### 3）交换两个数

```c
void Swap(int &a, int &b){
	if (a != b){
		a ^= b;
		b ^= a; //b =b^ a^b= a
		a ^= b; //a =a^b ^a= b
	}
}
```

##### 4）找出单次出现的数字

给出一堆乱序数字，只有一个数字出现了一次，其余数字都出现了两次，如何找出出现一次的这个数字？

例如：1，2，2，3，3

解答：将这些数字全部异或之后结果即为这个数字（ 1^2^2^3^3 = 1）。

### 2.4 取反运算符 (~)

**定义**：参加运算的一个数据，按二进制进行“取反”运算。
**运算规则**：　

```java
~1=0
~0=1
```

**总结**：对一个二进制数按位取反，即将0变1，1变0。

#### 常见面试题

##### 1）使一个数的二进制最低位为零

使a的最低位为0，可以表示为：`a & ~1`。

~1的值为 1111 1111 1111 1110，再按"与"运算，最低位一定为0。因为“ ~”运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。

### 2.5 左移运算符（`<<`）

**定义**：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，包括符号位0或1，右边补0）。

**例如**：设 a=1010 1110，`a = a<< 2` 将a的二进制位左移2位、右补0，即得a=1011 1000。

**说明**：若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。

下面用代码去测试<<运算：

```java
/**
 * 测试<<运算符
 * 正数变为负数，说明带第一位符号位位移
 */
@Test
public void test2() {
    int i = Integer.parseInt("0000 0000 0000 1111 1111 1111 1111 1111".replaceAll(" ", ""), 2);
    System.out.println(i);
    System.out.println(Integer.toBinaryString(i));
    int x = i << 13;
    System.out.println(x);
    String s = Integer.toBinaryString(x);
    System.out.println(s);
      1048575
      0000 0000 0000 1111 1111 1111 1111 1111
      -8192
      1111 1111 1111 1111 1110 0000 0000 0000
}
/**
 * 测试<<运算符
 * 负数变为正数，说明带第一位符号位位移
 */
@Test
public void test3() {
    int i = Integer.parseInt("-0000 0000 0000 1111 1111 1111 1111 1111".replaceAll(" ", ""), 2);
    System.out.println(i);
    System.out.println(Integer.toBinaryString(i));
    int x = i << 13;
    System.out.println(x);
    String s = Integer.toBinaryString(x);
    System.out.println(s);
      -1048575
      1111 1111 1111 0000 0000 0000 0000 0001 （负数在机器上是以补码的形式存放的）
      8192
      0000 0000 0000 0000 0010 0000 0000 0000
}
```

### 2.6 右移运算符（`>>`）

**定义**：将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。

**例如**：`a=a>>2` 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。

**说明**：操作数每右移一位，相当于该数除以2。

下面用代码去测试>>运算：

```java
/**
 * 测试>>运算符
 * 正数右移，左边补0
 */
@Test
public void test4() {
    int i = Integer.parseInt("0000 0000 0000 1111 1111 1111 1111 1111".replaceAll(" ", ""), 2);
    System.out.println(i);
    System.out.println(Integer.toBinaryString(i));
    int x = i >> 2;
    System.out.println(x);
    String s = Integer.toBinaryString(x);
    System.out.println(s);
      1048575
      0000 0000 0000 1111 1111 1111 1111 1111
      262143
      0000 0000 0000 0011 1111 1111 1111 1111
}
/**
 * 测试>>运算符
 * 负数右移，左边补1
 */
@Test
public void test5() {
    int i = Integer.parseInt("-0000 0000 0000 1111 1111 1111 1111 1111".replaceAll(" ", ""), 2);
    System.out.println(i);
    System.out.println(Integer.toBinaryString(i));
    int x = i >> 2;
    System.out.println(x);
    String s = Integer.toBinaryString(x);
    System.out.println(s);
      -1048575
      1111 1111 1111 0000 0000 0000 0000 0001（负数在机器上是以补码的形式存放的）
      -262144
      1111 1111 1111 1100 0000 0000 0000 0000
}
```

### 2.7 无符号右移（`>>>`）

在计算机中负数采用二进制的补码表示，即10进制转为2进制得到的是原码，将原码除第一个符号位外按位取反得到的是反码，反码加1得到补码。

二进制的最高位是符号位，0表示正，1表示负。

`>>>`与`>>`唯一的不同是它无论原来的最左边是什么数，统统都用0填充。

**举例**：-1的32进制位

原码 :     1000 0000 0000 0000 0000 0000 0000 0001

反码 :     1111 1111 1111 1111 1111 1111 1111 1110

补码 :     1111 1111 1111 1111 1111 1111 1111 1111 （在反码基础上+1）

`a<<2`:    1111 1111 1111 1111 1111 1111 1111 1100

`a>>2`:    1111 1111 1111 1111 1111 1111 1111 1111  （右移两位，左边高位再补两个1，所以看着没什么变化）

`a>>>2`:  0011 1111 1111 1111 1111 1111 1111 1111  (无符号右移跟上个比起来就是高位不补1)

### 2.8 复合赋值运算符

位运算符与赋值运算符结合，组成新的复合赋值运算符，它们是：

`&=` 例：`a&=b`相当于`a=a&b`

`|=` 例：`a|=b`相当于`a=a|b`

`>>=` 例：`a>>=b`相当于`a=a>>b`

`<<=` 例：`a<<=b` 相当于`a=a<<b`

`^=` 例：`a^=b`相当于`a=a^b`

**不同长度的数据进行位运算**：如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。

以“与运算”为例说明如下：我们知道在C语言中long型占4个字节，int型占2个字节，如果一个long型数据与一个int型数据进行“与运算“，右端对齐后，左边不足的位依下面三种情况补足，

**1）**如果整型数据为正数，左边补16个0

例如：long a=123，int b=1，计算a&b.

**2）**如果整型数据为负数，左边补16个1

例如：long a=123，int b=-1，计算a&b.

**3）**如果整形数据为无符号数，左边也补16个0

例如：`long a=123，unsigned int b=1`，计算`a&b`.

## 参考文章

[位运算总结(按位与,或,异或)](https://blog.csdn.net/sinat_35121480/article/details/53510793)

[关于位运算看这个就够了](https://juejin.im/post/5a5886bef265da3e38496fd5)

[位操作基础篇之位操作全面总结](https://blog.csdn.net/MoreWindows/article/details/7354571)