---
layout: post
title: 深入理解［Future模式］原理与技术
date: 2018-09-21 17:31:00
author: 薛勤
tags: 设计模式
---
## 1.Future模式

> Future模式和多线程技术密切相关，可以说是利用多线程技术优化程序的一个实例。

在程序设计中，当某一段程序提交了一个请求，期望得到一个答复。但非常不幸的是，服务程序对这个请求的处理可能比较慢，比如，这个请求可能是通过互联网、HTTP或者Web Service等并不高效的方式调用的。在传统的单线程环境下，调用函数是同步的，也就是说它必须等到服务程序返回结束后，才能进行其他处理。而在Future模式下，调用方式改为异步的，而原先等待返回的时间段，在主调用函数中，则可能用于处理其它事务。下面我们尝试实现这一功能：

1）Main方法的实现

main方法主要负责调用Client发起请求，并使用返回的数据：

```java
public class Future {
    public static void main(String[] args) {
        Client client = new Client();
        Data data = client.request("name");
        System.out.println("请求完毕 "+System.currentTimeMillis());
        //...这里做一些其它任务
        System.out.println("数据："+data.getResult());
        System.out.println("获取完毕 "+System.currentTimeMillis());
    }
}
```

2）Client的实现

client主要实现了获取FutureData，开启构造RealData的线程，并在接受请求后，很快的返回FutureData。

```java
public class Client {
    public Data request(String queryStr){
        FutureData futureData = new FutureData();
        new Thread(new Runnable() {
            @Override
            public void run() {
                RealData realData =  new RealData(queryStr);
                futureData.setRealData(realData);
            }
        }).start();
        return futureData;
    }
}
```

3）Data的实现

Data是一个接口，提供了getResult()方法。

```java
public interface Data {
    String getResult();
}
```

4）FutureData的实现

FutureData 实现了一个快速返回的RealData 包装。它只是一个包装，或者说是一个RealData 的虚拟实现 。因此，它可以很快被构造并返回。当使用FutureData的getResult()方法时，程序会阻塞，等待RealData()被注入到程序中，才使用RealData的getResult()方法返回。

```java
public class FutureData implements Data {
    private  RealData realData = null;
    private  boolean isReady = false;

    synchronized public void setRealData(RealData realData){
        if (isReady){
            return;
        }
        this.realData = realData;
        isReady = true;
        notifyAll(); //通知所有等待的线程继续运行
    }

    @Override
    synchronized public String getResult() {
        while (!isReady){
            try {
                System.out.print("...waiting...");
                wait(); //使当前线程在此处进行等待，直到被通知后继续运行
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        return realData.result;
    }
}
```

5）RealData 的实现

RealData 是最终需要使用的数据模型，它的构造很慢。在这里，使用sleep()函数模拟这个过程。

```java
public class RealData implements Data {
    protected String result;

    public RealData(String para) {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        result = "["+para+"]";
    }

    @Override
    public String getResult() {
        return result;
    }
}
```

运行结果：

```java
请求完毕 1537520554813
...waiting...
数据：[name]
获取完毕 1537520555890
```

程序运行的流程是Main线程去获取数据，但是数据还在处理中，于是Main线程进入等待状态，当数据处理完并通知等待所有等待的线程之后，Main线程得以继续运行下去。

## 2.JDK的内置实现

Future模式如此常用，以至于在JDK的并发包中，就已经内置了一种Future模式的实现了。

示例程序：

```java
public class RealData implements Callable<String> {
    private String para;

    public RealData(String para) {
        this.para = para;
    }

    @Override
    public String call() throws Exception {
        //这里是真实的业务逻辑
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "["+para+"]";
    }
    
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //传入RealData到FutureTask
        FutureTask<String> futureTask = new FutureTask<String>(new RealData("name"));
        //创建一个线程池
        ExecutorService executorService = Executors.newFixedThreadPool(1);
        //在这里开启线程执行RealData的call()方法
        executorService.submit(futureTask);
        System.out.println("请求完毕 "+System.currentTimeMillis());
        //...这里进行一些其它操作
        System.out.println("数据："+futureTask.get());
        System.out.println("获取完毕 "+System.currentTimeMillis());
        //启动一个有序的关闭，之前提交的任务将被执行，但是不会接受新的任务。
        executorService.shutdown();
    }
    
}
```

运行结果：

```java
请求完毕 1537521833970
数据：[name]
获取完毕 1537521834977
```

Callable接口是一个用户自定义实现的接口。在应用程序中，通过实现Callable接口的call()方法，指定FutureTask的实际内容和返回对象。

Future接口提供的线程控制功能有：

```java
//取消任务
boolean cancel(boolean mayInterruptIfRunning)
//是否已经取消
boolean isCancelled()
//是否已经完成
boolean isDone()
//取得返回对象
V get() throws InterruptedException, ExecutionException
//取得返回对象，可以设置超时时间
V get(long timeout, TimeUnit unit)
```

## 尾声

Future模式的核心在于使用多线程技术去除了主函数中的等待时间，并使得原来需要等待的时间段可以用于处理其他的业务逻辑，从而充分利用计算机资源。

> 本文已授权微信公众号“后端技术精选”发布